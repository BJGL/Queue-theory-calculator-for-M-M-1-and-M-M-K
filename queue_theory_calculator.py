# -*- coding: utf-8 -*-
"""Queue Theory Calculator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/171Lc1fWCGrWVu5yqXaUxPO558SZBz62u
"""

def rho_mm1(lmbda, mu):
    """Traffic intensity for M/M/1."""
    rho = round(lmbda / mu, 4)
    return rho


def lq_mm1(lmbda, mu):
    """Average queue length for M/M/1."""
    lq = round((lmbda ** 2) / (mu * (mu - lmbda)), 4)
    return lq


def l_mm1(lq, rho):
    """Average number of customers in the system for M/M/1."""
    l_total = round(lq + rho, 4)
    return l_total


def wq_mm1(lq, lmbda):
    """Average waiting time in queue for M/M/1."""
    wq = round(lq / lmbda, 4)
    return wq


def w_mm1(wq, mu):
    """Average total time in system for M/M/1."""
    w_total = round(wq + (1 / mu), 4)
    return w_total


def p0_mm1(rho):
    """Probability of zero customers in system for M/M/1."""
    p0 = round(1 - rho, 4)
    return p0


def plq_mm1(n, rho, p0):
    """Probability that queue length > n for M/M/1."""
    total = 0
    for i in range(0, n + 1):
        p = round((rho ** i) * p0, 4)
        total += p

    probability = round(1 - total, 4)
    return probability


def rho_mmk(lmbda, mu, k):
    """Traffic intensity for M/M/k."""
    rho = round(lmbda / (k * mu), 4)
    return rho


def factorial(number):
    """Simple factorial function."""
    fact = 1
    for i in range(1, number + 1):
        fact *= i
    return fact


def p0_mmk(k, lmbda, mu):
    """Probability of zero customers in M/M/k."""
    total = 0
    for i in range(0, k):
        total += ((lmbda / mu) ** i) / factorial(i)

    p0 = round(
        1 / (total + (((lmbda / mu) ** k) / factorial(k)) * ((k * mu) / ((k * mu) - lmbda))),
        4
    )
    return p0


def lq_mmk(p0, lmbda, mu, k):
    """Average queue length for M/M/k."""
    lq = round(
        (((lmbda / mu) ** k) * (lmbda * mu)) /
        ((k - 1) * ((k * mu - lmbda) ** 2)) * p0,
        4
    )
    return lq


def wq_mmk(lq, lmbda):
    """Average waiting time in queue for M/M/k."""
    wq = round(lq / lmbda, 4)
    return wq


def w_mmk(wq, mu):
    """Average total time in system for M/M/k."""
    w_total = round(wq + (1 / mu), 4)
    return w_total


def l_mmk(lq, lmbda, mu):
    """Average number of customers in the system for M/M/k."""
    l_total = round(lq + (lmbda / mu), 4)
    return l_total


def n_less_k(lmbda, mu, n, p0):
    """Probability for n < k in M/M/k."""
    probability = round((((lmbda / mu) ** n) / factorial(n)) * p0,4)
    return probability


def n_greater_k(lmbda, mu, n, p0, k):
    """Probability for n â‰¥ k in M/M/k."""
    probability = round((((lmbda / mu) ** n) / (factorial(k) * (k ** (n - k)))) * p0,4)
    return probability


def main():
    """Main program to choose between M/M/1 and M/M/k models."""
    question = int(input('1. M/M/1\n2. M/M/k\n\n'))

    if question == 1:
        lmbda = float(input('\nLambda: '))
        mu = float(input('\nMu: '))
        rho = rho_mm1(lmbda, mu)
        lq = lq_mm1(lmbda, mu)
        l_total = l_mm1(lq, rho)
        wq = wq_mm1(lq, lmbda)
        w_total = w_mm1(wq, mu)
        p0 = p0_mm1(rho)

        prob_question = input('\nP(Lq > ...)? \nYes \nNo\n\n').lower().strip()
        if prob_question == 'yes':
            n = int(input('\nHow many people?:\n '))
            probability = plq_mm1(n, rho, p0)
            print(
                f'\nrho = {rho}\nLq = {lq}\nL = {l_total}\nWq = {wq}\nW = {w_total}\nP0 = {p0}\n'
                f'P(Lq > {n}) = {probability}'
            )
        else:
            print(
                f'\nrho = {rho}\nLq = {lq}\nL = {l_total}\nWq = {wq}\nW = {w_total}\nP0 = {p0}\n'
            )

    elif question == 2:
        lmbda = float(input('\nLambda:\n '))
        mu = float(input('\nMu:\n '))
        k = int(input('\nK:\n '))
        rho = rho_mmk(lmbda, mu, k)
        p0 = p0_mmk(k, lmbda, mu)
        lq = lq_mmk(p0, lmbda, mu, k)
        l_total = l_mmk(lq, lmbda, mu)
        wq = wq_mmk(lq, lmbda)
        w_total = w_mmk(wq, mu)

        prob_question = input('\nP(Lq > ...)? \nYes \nNo\n\n').lower().strip()
        if prob_question == 'yes':
            n = int(input('\nHow many people?:\n '))
            prob1 = 0
            prob2 = 0

            for j in range(n + 1):
                if j <= k:
                    prob1 += n_less_k(lmbda, mu, j, p0)
                else:
                    prob2 += n_greater_k(lmbda, mu, j, p0, k)

            total_prob = round(1 - (prob1 + prob2),4)
            print(
                f'\nrho = {rho}\nLq = {lq}\nL = {l_total}\nWq = {wq}\nW = {w_total}\nP0 = {p0}\n'
                f'P(Lq > {n}) = {total_prob}'
            )
        else:
            print(
                f'\nrho = {rho}\nLq = {lq}\nL = {l_total}\nWq = {wq}\nW = {w_total}\nP0 = {p0}\n'
            )


main()